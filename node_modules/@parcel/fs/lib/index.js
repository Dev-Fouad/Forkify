var $ki5hV$path = require("path");
var $ki5hV$stream = require("stream");
var $ki5hV$util = require("util");
var $ki5hV$fs = require("fs");
var $ki5hV$parcelcore = require("@parcel/core");
var $ki5hV$parcelutils = require("@parcel/utils");
var $ki5hV$parcelwatcher = require("@parcel/watcher");
var $ki5hV$parcelfssearch = require("@parcel/fs-search");
var $ki5hV$assert = require("assert");
var $ki5hV$constants = require("constants");
var $ki5hV$parcelworkers = require("@parcel/workers");
var $ki5hV$events = require("events");

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}
function $parcel$exportWildcard(dest, source) {
  Object.keys(source).forEach(function(key) {
    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {
      return;
    }

    Object.defineProperty(dest, key, {
      enumerable: true,
      get: function get() {
        return source[key];
      }
    });
  });

  return dest;
}
function $parcel$export(e, n, v, s) {
  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});
}
var $parcel$global =
typeof globalThis !== 'undefined'
  ? globalThis
  : typeof self !== 'undefined'
  ? self
  : typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
  ? global
  : {};

$parcel$export(module.exports, "ncp", () => $e46c9778a96a2930$export$d3a8044e3fef7335);



var $10145ab9dc478fed$exports = {};

$parcel$export($10145ab9dc478fed$exports, "NodeFS", () => $10145ab9dc478fed$export$c4e0ef2ab73c21e7);
var $7250854f629b7e00$exports = {};

var $14ed6d859fc43bf5$exports = {};

var $14ed6d859fc43bf5$var$origCwd = process.cwd;
var $14ed6d859fc43bf5$var$cwd = null;
var $14ed6d859fc43bf5$var$platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
    if (!$14ed6d859fc43bf5$var$cwd) $14ed6d859fc43bf5$var$cwd = $14ed6d859fc43bf5$var$origCwd.call(process);
    return $14ed6d859fc43bf5$var$cwd;
};
try {
    process.cwd();
} catch (er) {}
var $14ed6d859fc43bf5$var$chdir = process.chdir;
process.chdir = function(d) {
    $14ed6d859fc43bf5$var$cwd = null;
    $14ed6d859fc43bf5$var$chdir.call(process, d);
};
$14ed6d859fc43bf5$exports = $14ed6d859fc43bf5$var$patch;
function $14ed6d859fc43bf5$var$patch(fs) {
    // (re-)implement some things that are known busted or missing.
    // lchmod, broken prior to 0.6.2
    // back-port the fix here.
    if ($ki5hV$constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) patchLchmod(fs);
    // lutimes implementation, or no-op
    if (!fs.lutimes) patchLutimes(fs);
    // https://github.com/isaacs/node-graceful-fs/issues/4
    // Chown should not fail on einval or eperm if non-root.
    // It should not fail on enosys ever, as this just indicates
    // that a fs doesn't support the intended operation.
    fs.chown = chownFix(fs.chown);
    fs.fchown = chownFix(fs.fchown);
    fs.lchown = chownFix(fs.lchown);
    fs.chmod = chmodFix(fs.chmod);
    fs.fchmod = chmodFix(fs.fchmod);
    fs.lchmod = chmodFix(fs.lchmod);
    fs.chownSync = chownFixSync(fs.chownSync);
    fs.fchownSync = chownFixSync(fs.fchownSync);
    fs.lchownSync = chownFixSync(fs.lchownSync);
    fs.chmodSync = chmodFixSync(fs.chmodSync);
    fs.fchmodSync = chmodFixSync(fs.fchmodSync);
    fs.lchmodSync = chmodFixSync(fs.lchmodSync);
    fs.stat = statFix(fs.stat);
    fs.fstat = statFix(fs.fstat);
    fs.lstat = statFix(fs.lstat);
    fs.statSync = statFixSync(fs.statSync);
    fs.fstatSync = statFixSync(fs.fstatSync);
    fs.lstatSync = statFixSync(fs.lstatSync);
    // if lchmod/lchown do not exist, then make them no-ops
    if (!fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchmodSync = function() {};
    }
    if (!fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
            if (cb) process.nextTick(cb);
        };
        fs.lchownSync = function() {};
    }
    // on Windows, A/V software can lock the directory, causing this
    // to fail with an EACCES or EPERM if the directory contains newly
    // created files.  Try again on failure, for up to 60 seconds.
    // Set the timeout this long because some Windows Anti-Virus, such as Parity
    // bit9, may lock files for up to a minute, causing npm package install
    // failures. Also, take care to yield the scheduler. Windows scheduling gives
    // CPU to a busy looping process, which can cause the program causing the lock
    // contention to be starved of CPU by node, so the contention doesn't resolve.
    if ($14ed6d859fc43bf5$var$platform === "win32") fs.rename = function(fs$rename) {
        return function(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
                if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 60000) {
                    setTimeout(function() {
                        fs.stat(to, function(stater, st) {
                            if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);
                            else cb(er);
                        });
                    }, backoff);
                    if (backoff < 100) backoff += 10;
                    return;
                }
                if (cb) cb(er);
            });
        };
    }(fs.rename);
    // if read() returns EAGAIN, then just try it again.
    fs.read = function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
            var callback;
            if (callback_ && typeof callback_ === "function") {
                var eagCounter = 0;
                callback = function(er, _, __) {
                    if (er && er.code === "EAGAIN" && eagCounter < 10) {
                        eagCounter++;
                        return fs$read.call(fs, fd, buffer, offset, length, position, callback);
                    }
                    callback_.apply(this, arguments);
                };
            }
            return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        // This ensures `util.promisify` works as it does for native `fs.read`.
        read.__proto__ = fs$read;
        return read;
    }(fs.read);
    fs.readSync = function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
            var eagCounter = 0;
            while(true)try {
                return fs$readSync.call(fs, fd, buffer, offset, length, position);
            } catch (er) {
                if (er.code === "EAGAIN" && eagCounter < 10) {
                    eagCounter++;
                    continue;
                }
                throw er;
            }
        };
    }(fs.readSync);
    function patchLchmod(fs) {
        fs.lchmod = function(path, mode, callback) {
            fs.open(path, $ki5hV$constants.O_WRONLY | $ki5hV$constants.O_SYMLINK, mode, function(err, fd) {
                if (err) {
                    if (callback) callback(err);
                    return;
                }
                // prefer to return the chmod error, if one occurs,
                // but still try to close, and report closing errors if they occur.
                fs.fchmod(fd, mode, function(err) {
                    fs.close(fd, function(err2) {
                        if (callback) callback(err || err2);
                    });
                });
            });
        };
        fs.lchmodSync = function(path, mode) {
            var fd = fs.openSync(path, $ki5hV$constants.O_WRONLY | $ki5hV$constants.O_SYMLINK, mode);
            // prefer to return the chmod error, if one occurs,
            // but still try to close, and report closing errors if they occur.
            var threw = true;
            var ret;
            try {
                ret = fs.fchmodSync(fd, mode);
                threw = false;
            } finally{
                if (threw) try {
                    fs.closeSync(fd);
                } catch (er) {}
                else fs.closeSync(fd);
            }
            return ret;
        };
    }
    function patchLutimes(fs) {
        if ($ki5hV$constants.hasOwnProperty("O_SYMLINK")) {
            fs.lutimes = function(path, at, mt, cb) {
                fs.open(path, $ki5hV$constants.O_SYMLINK, function(er, fd) {
                    if (er) {
                        if (cb) cb(er);
                        return;
                    }
                    fs.futimes(fd, at, mt, function(er) {
                        fs.close(fd, function(er2) {
                            if (cb) cb(er || er2);
                        });
                    });
                });
            };
            fs.lutimesSync = function(path, at, mt) {
                var fd = fs.openSync(path, $ki5hV$constants.O_SYMLINK);
                var ret;
                var threw = true;
                try {
                    ret = fs.futimesSync(fd, at, mt);
                    threw = false;
                } finally{
                    if (threw) try {
                        fs.closeSync(fd);
                    } catch (er) {}
                    else fs.closeSync(fd);
                }
                return ret;
            };
        } else {
            fs.lutimes = function(_a, _b, _c, cb) {
                if (cb) process.nextTick(cb);
            };
            fs.lutimesSync = function() {};
        }
    }
    function chmodFix(orig) {
        if (!orig) return orig;
        return function(target, mode, cb) {
            return orig.call(fs, target, mode, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chmodFixSync(orig) {
        if (!orig) return orig;
        return function(target, mode) {
            try {
                return orig.call(fs, target, mode);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function chownFix(orig) {
        if (!orig) return orig;
        return function(target, uid, gid, cb) {
            return orig.call(fs, target, uid, gid, function(er) {
                if (chownErOk(er)) er = null;
                if (cb) cb.apply(this, arguments);
            });
        };
    }
    function chownFixSync(orig) {
        if (!orig) return orig;
        return function(target, uid, gid) {
            try {
                return orig.call(fs, target, uid, gid);
            } catch (er) {
                if (!chownErOk(er)) throw er;
            }
        };
    }
    function statFix(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options, cb) {
            if (typeof options === "function") {
                cb = options;
                options = null;
            }
            function callback(er, stats) {
                if (stats) {
                    if (stats.uid < 0) stats.uid += 0x100000000;
                    if (stats.gid < 0) stats.gid += 0x100000000;
                }
                if (cb) cb.apply(this, arguments);
            }
            return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
    }
    function statFixSync(orig) {
        if (!orig) return orig;
        // Older versions of Node erroneously returned signed integers for
        // uid + gid.
        return function(target, options) {
            var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
            if (stats.uid < 0) stats.uid += 0x100000000;
            if (stats.gid < 0) stats.gid += 0x100000000;
            return stats;
        };
    }
    // ENOSYS means that the fs doesn't support the op. Just ignore
    // that, because it doesn't matter.
    //
    // if there's no getuid, or if getuid() is something other
    // than 0, and the error is EINVAL or EPERM, then just ignore
    // it.
    //
    // This specific case is a silent failure in cp, install, tar,
    // and most other unix tools that manage permissions.
    //
    // When running as root, or if other types of errors are
    // encountered, then it's strict.
    function chownErOk(er) {
        if (!er) return true;
        if (er.code === "ENOSYS") return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
            if (er.code === "EINVAL" || er.code === "EPERM") return true;
        }
        return false;
    }
}


var $ec8337b8453e4d66$exports = {};

var $ec8337b8453e4d66$require$Stream = $ki5hV$stream.Stream;
$ec8337b8453e4d66$exports = $ec8337b8453e4d66$var$legacy;
function $ec8337b8453e4d66$var$legacy(fs) {
    return {
        ReadStream: ReadStream,
        WriteStream: WriteStream
    };
    function ReadStream(path, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path, options);
        $ec8337b8453e4d66$require$Stream.call(this);
        var self = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438; /*=0666*/ 
        this.bufferSize = 65536;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== undefined) {
            if ("number" !== typeof this.start) throw TypeError("start must be a Number");
            if (this.end === undefined) this.end = Infinity;
            else if ("number" !== typeof this.end) throw TypeError("end must be a Number");
            if (this.start > this.end) throw new Error("start must be <= end");
            this.pos = this.start;
        }
        if (this.fd !== null) {
            process.nextTick(function() {
                self._read();
            });
            return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
            if (err) {
                self.emit("error", err);
                self.readable = false;
                return;
            }
            self.fd = fd;
            self.emit("open", fd);
            self._read();
        });
    }
    function WriteStream(path, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path, options);
        $ec8337b8453e4d66$require$Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438; /*=0666*/ 
        this.bytesWritten = 0;
        options = options || {};
        // Mixin options into this
        var keys = Object.keys(options);
        for(var index = 0, length = keys.length; index < length; index++){
            var key = keys[index];
            this[key] = options[key];
        }
        if (this.start !== undefined) {
            if ("number" !== typeof this.start) throw TypeError("start must be a Number");
            if (this.start < 0) throw new Error("start must be >= zero");
            this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
            this._open = fs.open;
            this._queue.push([
                this._open,
                this.path,
                this.flags,
                this.mode,
                undefined
            ]);
            this.flush();
        }
    }
}


var $142b189e92f6750b$exports = {};
"use strict";
$142b189e92f6750b$exports = $142b189e92f6750b$var$clone;
function $142b189e92f6750b$var$clone(obj) {
    if (obj === null || typeof obj !== "object") return obj;
    if (obj instanceof Object) var copy = {
        __proto__: obj.__proto__
    };
    else var copy = Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
}



/* istanbul ignore next - node 0.x polyfill */ var $7250854f629b7e00$var$gracefulQueue;
var $7250854f629b7e00$var$previousSymbol;
/* istanbul ignore else - node 0.x polyfill */ if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    $7250854f629b7e00$var$gracefulQueue = Symbol.for("graceful-fs.queue");
    // This is used in testing by future versions
    $7250854f629b7e00$var$previousSymbol = Symbol.for("graceful-fs.previous");
} else {
    $7250854f629b7e00$var$gracefulQueue = "___graceful-fs.queue";
    $7250854f629b7e00$var$previousSymbol = "___graceful-fs.previous";
}
function $7250854f629b7e00$var$noop() {}
function $7250854f629b7e00$var$publishQueue(context, queue) {
    Object.defineProperty(context, $7250854f629b7e00$var$gracefulQueue, {
        get: function() {
            return queue;
        }
    });
}
var $7250854f629b7e00$var$debug = $7250854f629b7e00$var$noop;
if ($ki5hV$util.debuglog) $7250854f629b7e00$var$debug = $ki5hV$util.debuglog("gfs4");
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) $7250854f629b7e00$var$debug = function() {
    var m = $ki5hV$util.format.apply($ki5hV$util, arguments);
    m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
    console.error(m);
};

// Once time initialization
if (!$ki5hV$fs[$7250854f629b7e00$var$gracefulQueue]) {
    // This queue can be shared by multiple loaded instances
    var $7250854f629b7e00$var$queue = $parcel$global[$7250854f629b7e00$var$gracefulQueue] || [];
    $7250854f629b7e00$var$publishQueue($ki5hV$fs, $7250854f629b7e00$var$queue);
    // Patch fs.close/closeSync to shared queue version, because we need
    // to retry() whenever a close happens *anywhere* in the program.
    // This is essential when multiple graceful-fs instances are
    // in play at the same time.
    $ki5hV$fs.close = function(fs$close) {
        function close(fd, cb) {
            return fs$close.call($ki5hV$fs, fd, function(err) {
                // This function uses the graceful-fs shared queue
                if (!err) $7250854f629b7e00$var$retry();
                if (typeof cb === "function") cb.apply(this, arguments);
            });
        }
        Object.defineProperty(close, $7250854f629b7e00$var$previousSymbol, {
            value: fs$close
        });
        return close;
    }($ki5hV$fs.close);
    $ki5hV$fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
            // This function uses the graceful-fs shared queue
            fs$closeSync.apply($ki5hV$fs, arguments);
            $7250854f629b7e00$var$retry();
        }
        Object.defineProperty(closeSync, $7250854f629b7e00$var$previousSymbol, {
            value: fs$closeSync
        });
        return closeSync;
    }($ki5hV$fs.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) process.on("exit", function() {
        $7250854f629b7e00$var$debug($ki5hV$fs[$7250854f629b7e00$var$gracefulQueue]);
        $ki5hV$assert.equal($ki5hV$fs[$7250854f629b7e00$var$gracefulQueue].length, 0);
    });
}
if (!$parcel$global[$7250854f629b7e00$var$gracefulQueue]) $7250854f629b7e00$var$publishQueue($parcel$global, $ki5hV$fs[$7250854f629b7e00$var$gracefulQueue]);
$7250854f629b7e00$exports = $7250854f629b7e00$var$patch($142b189e92f6750b$exports($ki5hV$fs));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !$ki5hV$fs.__patched) {
    $7250854f629b7e00$exports = $7250854f629b7e00$var$patch($ki5hV$fs);
    $ki5hV$fs.__patched = true;
}
function $7250854f629b7e00$var$patch(fs) {
    // Everything that references the open() function needs to be in here
    $14ed6d859fc43bf5$exports(fs);
    fs.gracefulify = $7250854f629b7e00$var$patch;
    fs.createReadStream = createReadStream;
    fs.createWriteStream = createWriteStream;
    var fs$readFile = fs.readFile;
    fs.readFile = readFile;
    function readFile(path, options, cb) {
        if (typeof options === "function") cb = options, options = null;
        return go$readFile(path, options, cb);
        function go$readFile(path, options, cb) {
            return fs$readFile(path, options, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) $7250854f629b7e00$var$enqueue([
                    go$readFile,
                    [
                        path,
                        options,
                        cb
                    ]
                ]);
                else {
                    if (typeof cb === "function") cb.apply(this, arguments);
                    $7250854f629b7e00$var$retry();
                }
            });
        }
    }
    var fs$writeFile = fs.writeFile;
    fs.writeFile = writeFile;
    function writeFile(path, data, options, cb) {
        if (typeof options === "function") cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        function go$writeFile(path, data, options, cb) {
            return fs$writeFile(path, data, options, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) $7250854f629b7e00$var$enqueue([
                    go$writeFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ]
                ]);
                else {
                    if (typeof cb === "function") cb.apply(this, arguments);
                    $7250854f629b7e00$var$retry();
                }
            });
        }
    }
    var fs$appendFile = fs.appendFile;
    if (fs$appendFile) fs.appendFile = appendFile;
    function appendFile(path, data, options, cb) {
        if (typeof options === "function") cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        function go$appendFile(path, data, options, cb) {
            return fs$appendFile(path, data, options, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE")) $7250854f629b7e00$var$enqueue([
                    go$appendFile,
                    [
                        path,
                        data,
                        options,
                        cb
                    ]
                ]);
                else {
                    if (typeof cb === "function") cb.apply(this, arguments);
                    $7250854f629b7e00$var$retry();
                }
            });
        }
    }
    var fs$readdir = fs.readdir;
    fs.readdir = readdir;
    function readdir(path, options, cb) {
        var args = [
            path
        ];
        if (typeof options !== "function") args.push(options);
        else cb = options;
        args.push(go$readdir$cb);
        return go$readdir